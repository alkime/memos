---
title: "PR Comments as a Training Loop"
date: "2025-11-10T14:00:00-08:00"
author: James
voiceBased: true
draft: false
pinned: true

tags: ["AI Assisted Dev", "Working In The Open"]
---

# PR Comments as a Training Loop

This is kind of a sidecar to my previous post about [kicking off the Voice CLI project]({{< ref "2025-11-voice-cli-kickoff.md" >}})—maybe not really a follow-up, or maybe just going one level deeper on something that worked really well.

## Treating the LLM Like a Smart Junior Dev

As I mentioned in that post, the initial Voice CLI phase we were working on ended up needing a fair number of corrections. What I ended up doing was working with a flow I'm very familiar with: going in and making inline comments on the PR.

This fits into a core principle of this work: **treat the LLM like a smart junior dev**. And one of the main workflows anyone would be familiar with is the pull request review process—giving feedback, making suggestions on how to make changes, things like that.

What's nice about this approach is that those comments are embedded in the PR and can be easily fetched with the GitHub API—whether that's through the API itself, the `gh` command line tool, or one of the SDKs out there.

I ended up creating a small Python script that calls out to the GitHub API by calling `gh`. I'm sure there's a Python SDK for this stuff, but I liked the zero-code-dependency approach that just invoking the command line gets you. To get the specific comments, I needed to hit the GraphQL endpoint, which you can actually call with `gh api graphql`. You can check out the full script below, which was generated by Claude after a bit of back and forth. (I had initially wanted to have it be way more command line + `jq` focused).

## Determinism Over Flexibility

I think this is actually a great example of when actual code's determinism can beat out the flexibility you get with agent processing. Obviously agent is still in the loop here, but this gets at another core principle: **when you can add determinism to your the system, you almost always should**. Or similarly, the less you need to the LLM to do, the less it can F it up.

Giving my "junior dev" the ability to read and act to my comments worked really well. I could prompt it to just read the comments and make the changes, and it made the plan, executed it all, and did a great job getting everything into a mergeable state pretty easily. It worked really well.

And it all felt really familiar, working a workflow I've done hundreds of times before.

## Learning

Continuing with the idea that the LLM is a smart junior dev who takes feedback on their changes well. The expectation I'd have with a new team member is that they don't need to many passes on a given concept to bring it into how they operate on the codebase. I'd expect the dev to be taking the feedback, internalizing it, and apply that new knowledge for the next time they encounter it.

How do we create a similar feedback loop? I'm not totally sure, but my working hypothesis is to crystalize the review into the LLM's memory / context. This prompted me to generate a new doc in my docs directory that was the initial pieces of something akin to a style guide.

So now the last piece of the puzzle when prompting Claude to make changes based on PR comments is to inspect the current guide and make any updates that are missing based on the PR feedback. Basically, whenever you encounter a gap in how the LLM operates, encode a fix for it in the repo's context so that it can have a shot of not stepping in it in the future.

# Appendix: format_pr.py

```python
#!/usr/bin/env python3
"""Format GitHub PR inline comments as Markdown.

Uses GitHub GraphQL API to fetch review threads with resolved status.

Usage with gh CLI:
    ./format_pr.py [PR_NUMBER]

If PR_NUMBER is not provided, uses the current PR from the branch.
"""

import json
import subprocess
import sys

def run_gh_command(args):
    """Run a gh CLI command and return the output."""
    result = subprocess.run(
        ['gh'] + args,
        capture_output=True,
        text=True,
        check=True
    )
    return result.stdout

def get_repo_info():
    """Get the owner and repo name from the current git repository."""
    # Get remote URL
    result = subprocess.run(
        ['git', 'config', '--get', 'remote.origin.url'],
        capture_output=True,
        text=True,
        check=True
    )
    url = result.stdout.strip()

    # Parse owner/repo from URL (handles both HTTPS and SSH)
    # Example: git@github.com:owner/repo.git or https://github.com/owner/repo.git
    if 'github.com' in url:
        parts = url.split('github.com')[-1].strip(':/')
        parts = parts.replace('.git', '')
        owner, repo = parts.split('/')[:2]
        return owner, repo

    raise ValueError(f"Could not parse GitHub repo from URL: {url}")

def get_pr_number():
    """Get the PR number for the current branch.

    Returns None if no PR exists for the current branch.
    """
    try:
        output = run_gh_command(['pr', 'view', '--json', 'number', '-q', '.number'])
        return int(output.strip())
    except subprocess.CalledProcessError:
        return None

def fetch_review_threads(owner, repo, pr_number):
    """Fetch review threads using GitHub GraphQL API."""
    query = """
    query($owner: String!, $repo: String!, $pr: Int!) {
      repository(owner: $owner, name: $repo) {
        pullRequest(number: $pr) {
          reviewThreads(first: 100) {
            nodes {
              isResolved
              isOutdated
              comments(first: 100) {
                nodes {
                  id
                  author {
                    login
                  }
                  body
                  path
                  line
                  diffHunk
                  url
                }
              }
            }
          }
        }
      }
    }
    """

    # Use gh api graphql command
    output = run_gh_command([
        'api', 'graphql',
        '-f', f'query={query}',
        '-F', f'owner={owner}',
        '-F', f'repo={repo}',
        '-F', f'pr={pr_number}'
    ])

    return json.loads(output)

def format_threads(data):
    """Format review threads as Markdown."""
    threads = data['data']['repository']['pullRequest']['reviewThreads']['nodes']

    # Count resolved vs unresolved
    resolved_count = sum(1 for t in threads if t['isResolved'])
    unresolved_count = len(threads) - resolved_count

    print(f"# PR Review Comments ({len(threads)} threads)\n")
    print(f"- **Unresolved:** {unresolved_count}")
    print(f"- **Resolved:** {resolved_count}\n")

    # Group by resolved status
    unresolved_threads = [t for t in threads if not t['isResolved']]
    resolved_threads = [t for t in threads if t['isResolved']]

    # Show unresolved first
    if unresolved_threads:
        print("## Unresolved Comments\n")
        for thread in unresolved_threads:
            format_thread(thread, resolved=False)

    if resolved_threads:
        print("## Resolved Comments\n")
        for thread in resolved_threads:
            format_thread(thread, resolved=True)

def format_thread(thread, resolved):
    """Format a single review thread."""
    comments = thread['comments']['nodes']
    if not comments:
        return

    # First comment is the main one
    first_comment = comments[0]
    author = first_comment['author']['login'] if first_comment['author'] else 'Unknown'
    path = first_comment.get('path', 'unknown file')
    line = first_comment.get('line', '?')
    body = first_comment.get('body', '')
    diff_hunk = first_comment.get('diffHunk', '')
    url = first_comment.get('url', '')

    status = "✅ RESOLVED" if resolved else "⚠️  UNRESOLVED"
    if thread.get('isOutdated'):
        status += " (outdated)"

    print(f"### [{status}] {author} on `{path}:{line}`\n")

    if url:
        print(f"[View on GitHub]({url})\n")

    # Include the code diff context if available
    if diff_hunk:
        print(f"```diff\n{diff_hunk}\n```\n")

    print(f"{body}\n")

    # Show replies if any
    if len(comments) > 1:
        print("**Replies:**\n")
        for reply in comments[1:]:
            reply_author = reply['author']['login'] if reply['author'] else 'Unknown'
            reply_body = reply.get('body', '')
            print(f"- **{reply_author}:** {reply_body}")
        print()

    print("---\n")

def main():
    try:
        # Get PR number from argument or current branch
        if len(sys.argv) > 1:
            pr_number = int(sys.argv[1])
        else:
            pr_number = get_pr_number()
            if pr_number is None:
                # Get current branch name for the message
                result = subprocess.run(
                    ['git', 'branch', '--show-current'],
                    capture_output=True,
                    text=True,
                    check=True
                )
                branch = result.stdout.strip()
                print(f"No pull request found for branch '{branch}'", file=sys.stderr)
                print("\nTo view comments for a specific PR, use: make pr-comments PR=<number>", file=sys.stderr)
                print("Or run: ./scripts/format_pr.py <PR_NUMBER>", file=sys.stderr)
                sys.exit(0)  # Exit cleanly, not an error condition

        # Get repo info
        owner, repo = get_repo_info()

        # Fetch and format review threads
        data = fetch_review_threads(owner, repo, pr_number)
        format_threads(data)

    except subprocess.CalledProcessError as e:
        print(f"Error running command: {e}", file=sys.stderr)
        print(f"Output: {e.stderr}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    main()

```

---
{{< byline >}}
